<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trích xuất nội dung truyện (TTS Một Nút - Sửa Pause/Resume)</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11.7.32/dist/sweetalert2.min.css">
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.7.32/dist/sweetalert2.all.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            color: #1a237e;
            font-size: 2.5em;
            text-transform: uppercase;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            background: linear-gradient(45deg, #1a237e, #3949ab);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h3 {
            color: #1a237e;
            border-bottom: 2px solid #1a237e;
            padding-bottom: 5px;
            margin-top: 25px;
        }
        div:not(#debugLogContainer) {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            resize: vertical;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
            font-size: 16px;
            box-sizing: border-box;
        }
        button {
            background-color: #1a237e;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: background-color 0.3s;
            font-size: 1em;
        }
        button:hover { background-color: #3949ab; }
        button:active { transform: translateY(1px); }
        button:disabled {
            background-color: #9e9e9e;
            cursor: not-allowed;
        }

        button[onclick="fetchMultipleUrls()"] { background-color: #2196F3; }
        button[onclick="generateNextUrls()"] { background-color: #9C27B0; }
        button[onclick="replaceWithNextUrls()"] { background-color: #FF5722; }
        button[onclick="showUrlHistory()"] { background-color: #FF9800; }
        button[onclick*="clearUrls"] { background-color: #f44336; }
        button[onclick="copyToClipboard()"] { background-color: #4CAF50; }
        
        button#speechControlButton { 
            background-color: #673AB7; /* Tím cho 'Đọc' */
            min-width: 120px; 
        }
        button#speechControlButton.playing { background-color: #FF9800; /* Cam cho 'Tạm dừng' */ }
        button#speechControlButton.paused { background-color: #4CAF50; /* Xanh lá cho 'Tiếp tục' */ }
        button#speechControlButton:disabled { background-color: #b39ddb; }


        #progress-container { display: none; background-color: #e0e0e0; border-radius: 5px; margin-bottom: 10px; padding: 10px; }
        #progress-bar { width: 100%; height: 20px; background-color: #ddd; border-radius: 5px; overflow: hidden; }
        #progress-bar-fill { width: 0%; height: 100%; background-color: #4CAF50; }
        #progress-text { text-align: center; margin-top: 5px; }
        
        #debugLogContainer { margin-top: 20px; padding: 10px; background-color: #222; color: #0f0; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #debugLog { height: 200px; overflow-y: scroll; border: 1px solid #444; background-color: #111; padding: 5px; font-family: 'Courier New', monospace; font-size: 0.8em; white-space: pre-wrap; color: #0f0; }
        #debugLog .warn { color: #ff0; }
        #debugLog .error { color: #f00; }

        @media (max-width: 768px) {
            body { padding: 10px; }
            button { width: 100%; margin-bottom: 5px; padding: 15px 30px; font-size: 1.1em; min-width: 100px; min-height: 48px; }
            #collection { margin-top: 10px; }
            textarea { font-size: 16px; }
        }
    </style>
</head>
<body>
    <h1>Trích xuất nội dung truyện (TTS Một Nút - Sửa Pause/Resume)</h1>

    <div>
        <h3>1. Nhập URLs (mỗi URL một dòng):</h3>
        <textarea id="urls" rows="5" cols="80" placeholder="https://truyenfull.bio/cuu-thien-kiem-ss-ha-than/chuong-110/"></textarea>
        <div id="progress-container"> </div> <br>
        <button onclick="fetchMultipleUrls()">Lấy nội dung tất cả URLs</button>
        <button onclick="generateNextUrls()">Tạo URL tiếp theo</button>
        <button onclick="replaceWithNextUrls()">Xóa và tạo 4 URL mới</button>
        <button onclick="showUrlHistory()">Lịch sử URL</button>
        <button onclick="clearUrls()">Xóa URLs</button>
    </div>

    <div>
        <h3>2. Tổng hợp nội dung:</h3>
        <button onclick="copyToClipboard()">Copy vào Clipboard</button>
        <button onclick="handleSpeechControl()" id="speechControlButton">Đọc</button> 
        <textarea id="collection" rows="20" cols="80" readonly>Tổng đốc Vương Thăng cau mày, khóe môi hiện lên một nụ cười khổ.
Sao hắn lại không biết mình nên quyết đoán chứ.
Nhưng cái quyết đoán này thật sự là không dễ.

Sau lưng Thái thú Tư Không Thiện là hoạn quan trong cung, sẽ không mặc cho
hắn muốn làm gì thì làm.
Thời gian gần đây, người này liên thủ với thân sĩ Tú Thủy, đầu tư ngàn vạn
lượng bạc để cấu kết và quan hệ với khắp nơi, trăm phương ngàn kế để đóng
đinh tội danh mưu phản cho Sở Hi Thanh và Thiết Kỳ Bang, cũng làm cho
Tổng đốc Đông Châu như hắn rơi vào hoàn cảnh lúng túng.
</textarea>
        <p><small>Lưu ý: Để đọc được tiếng Việt, thiết bị Android của bạn cần cài đặt và chọn gói giọng nói tiếng Việt trong cài đặt Text-to-Speech.</small></p>
    </div>

    <div id="debugLogContainer">
        <h4>Log gỡ lỗi TTS (Trên trang chính):</h4>
        <div id="debugLog"></div>
    </div>

    <script>
    // --- Phần ghi log ra div (giữ nguyên) ---
    let logDivElement = null;
    const originalConsoleLog = console.log; 
    const originalConsoleWarn = console.warn;
    const originalConsoleError = console.error;
    function appendToLogDiv(type, args) {
        if (logDivElement) {
            const message = Array.from(args).map(arg => {
                 if (arg instanceof ErrorEvent && arg.error === undefined) { return `ErrorEvent (error: undefined, message: ${arg.message || 'N/A'}, utterance: ${arg.utterance ? arg.utterance.text.substring(0,30) : 'N/A'})`; }
                if (arg instanceof SpeechSynthesisEvent) {  return `SpeechSynthesisEvent (type: ${arg.type}, charIndex: ${arg.charIndex}, elapsedTime: ${arg.elapsedTime}, name: ${arg.name}, utterance: ${arg.utterance.text.substring(0,30)})`; }
                if (arg instanceof Event) { return `Event (type: ${arg.type}, isTrusted: ${arg.isTrusted})`; }
                if (arg instanceof Error) return arg.stack || arg.message;
                if (typeof arg === 'object' && arg !== null) return JSON.stringify(arg, null, 2);
                return String(arg);
            }).join(' ');
            const entry = document.createElement('div');
            entry.className = type.toLowerCase();
            entry.textContent = `[${type.toUpperCase()}] ${new Date().toLocaleTimeString()}: ${message}`;
            logDivElement.appendChild(entry);
            logDivElement.scrollTop = logDivElement.scrollHeight;
        }
    }
    console.log = function(...args) { originalConsoleLog.apply(console, args); appendToLogDiv('LOG', args); };
    console.warn = function(...args) { originalConsoleWarn.apply(console, args); appendToLogDiv('WARN', args); };
    console.error = function(...args) { originalConsoleError.apply(console, args); appendToLogDiv('ERROR', args); };
    // --- Kết thúc phần ghi log ra div ---

    const URLS_STORAGE_KEY = 'savedStoryUrls'; 
    const HISTORY_STORAGE_KEY = 'urlHistory';
    const MAX_HISTORY_SIZE = 50;

    let currentUtterance = null;
    let ttsVoices = []; 
    let ttsVoicesLoadedAtLeastOnce = false;
    let speechControlButton; 
    
    let speechChunks = [];
    let currentChunkIndex = 0;
    let ttsState = 'idle'; // Trạng thái: 'idle', 'playing', 'paused'


    function populateVoiceList() {
        console.log("populateVoiceList được gọi.");
        if (typeof speechSynthesis === 'undefined') { console.warn('speechSynthesis không được hỗ trợ.'); return; }
        ttsVoices = speechSynthesis.getVoices();
        if (ttsVoices.length > 0) {
            ttsVoicesLoadedAtLeastOnce = true;
            console.log("Danh sách giọng đọc đã được tải.");
        } else {
            console.warn("Danh sách giọng đọc vẫn trống sau khi onvoiceschanged/populate.");
        }
        console.log("Số lượng giọng đọc:", ttsVoices.length, ". Đã tải ít nhất một lần:", ttsVoicesLoadedAtLeastOnce);
        updateSpeechControlButton(); 
    }

    function updateSpeechControlButton() {
        if (!speechControlButton) speechControlButton = document.getElementById('speechControlButton');
        if (!speechControlButton) return;

        const collectionText = document.getElementById('collection').value;
        const hasText = collectionText.trim() !== '';

        speechControlButton.classList.remove('playing', 'paused');

        if (ttsState === 'playing') {
            speechControlButton.textContent = 'Tạm dừng';
            speechControlButton.disabled = false;
            speechControlButton.classList.add('playing');
        } else if (ttsState === 'paused') {
            speechControlButton.textContent = 'Tiếp tục';
            speechControlButton.disabled = false;
            speechControlButton.classList.add('paused');
        } else { // idle
            speechControlButton.textContent = 'Đọc';
            speechControlButton.disabled = !hasText || !ttsVoicesLoadedAtLeastOnce; 
            if (!ttsVoicesLoadedAtLeastOnce) {
                console.warn("Nút Đọc bị vô hiệu hóa vì TTS chưa sẵn sàng (giọng đọc chưa tải).");
            } else if (!hasText) {
                console.log("Nút Đọc bị vô hiệu hóa vì không có nội dung.");
            }
        }
        console.log(`Nút điều khiển được cập nhật: Text='${speechControlButton.textContent}', Disabled=${speechControlButton.disabled}, State=${ttsState}`);
    }

    function speakNextChunk() {
        console.log(`speakNextChunk: ttsState=${ttsState}, currentChunkIndex=${currentChunkIndex}, totalChunks=${speechChunks.length}`);
        if (ttsState !== 'playing' || currentChunkIndex >= speechChunks.length) {
            console.log("Kết thúc hàng đợi đọc chunk hoặc đã dừng/tạm dừng hoàn toàn.");
            if (ttsState !== 'paused') { 
                 ttsState = 'idle';
            }
            updateSpeechControlButton();
            return;
        }

        const chunkText = speechChunks[currentChunkIndex];
        console.log(`Chuẩn bị đọc chunk ${currentChunkIndex + 1}/${speechChunks.length}: "${chunkText.substring(0, 50)}..."`);

        currentUtterance = new SpeechSynthesisUtterance(chunkText);
        currentUtterance.lang = 'vi-VN';

        currentUtterance.onstart = (event) => {
            console.log(`Sự kiện onstart cho chunk ${currentChunkIndex + 1}.`, event);
            if (ttsState !== 'playing') {
                console.warn("onstart được gọi nhưng ttsState không phải 'playing'. Đặt lại thành 'playing'.");
                ttsState = 'playing';
            }
            updateSpeechControlButton(); 
        };
        
        currentUtterance.onpause = (event) => { 
            console.log(`Sự kiện Utterance ONPAUSE cho chunk ${currentChunkIndex + 1}. speechState.paused=${speechSynthesis.paused}`, event);
        };
        
        currentUtterance.onresume = (event) => { 
            console.log(`Sự kiện Utterance ONRESUME cho chunk ${currentChunkIndex + 1}. speechState.paused=${speechSynthesis.paused}`, event);
        };

        currentUtterance.onend = (event) => {
            console.log(`Sự kiện onend cho chunk ${currentChunkIndex + 1}. Hiện tại ttsState=${ttsState}, speechSynthesis.speaking=${speechSynthesis.speaking}, speechSynthesis.paused=${speechSynthesis.paused}`, event);
            const previousUtteranceText = currentUtterance ? currentUtterance.text.substring(0,30) : "N/A"; 
            currentUtterance = null; 

            if (ttsState === 'playing') { 
                console.log(`onend: ttsState is 'playing'. Incrementing chunk index from ${currentChunkIndex}. Utterance was: ${previousUtteranceText}`);
                currentChunkIndex++;
                if (currentChunkIndex < speechChunks.length) {
                    console.log(`onend: Calling speakNextChunk for new index ${currentChunkIndex}.`);
                    speakNextChunk(); 
                } else {
                    console.log("Đã đọc hết tất cả các chunk. Chuyển ttsState sang 'idle'.");
                    ttsState = 'idle';
                    updateSpeechControlButton();
                }
            } else if (ttsState === 'paused') {
                 console.log("onend được gọi nhưng ttsState là 'paused'. Chunk này có thể đã kết thúc trong khi tạm dừng. Sẽ tăng currentChunkIndex.");
                 currentChunkIndex++; 
                 if (currentChunkIndex >= speechChunks.length) {
                     console.log("Đã ở cuối danh sách chunk trong khi paused và onend được gọi. Chuyển về idle.");
                     ttsState = 'idle';
                     updateSpeechControlButton();
                 }
                 // Nút vẫn là "Tiếp tục", đợi người dùng nhấn.
            } else { 
                console.log(`onend được gọi nhưng ttsState là '${ttsState}'. Không đọc chunk tiếp theo.`);
                updateSpeechControlButton(); 
            }
        };

        currentUtterance.onerror = (event) => {
            console.error(`Sự kiện onerror TTS cho chunk ${currentChunkIndex + 1}:`, event.error, event);
            if (ttsState !== 'idle' && !(event.error === 'canceled' || event.error === 'interrupted')) {
                let displayError = event.error ? event.error : "Lỗi không xác định";
                Swal.fire('Lỗi đọc TTS', `Đã xảy ra lỗi khi đọc chunk ${currentChunkIndex + 1}: ${displayError}.`, 'error');
            } else {
                console.warn(`Lỗi onerror (${event.error}) được bỏ qua do ttsState là '${ttsState}' hoặc lỗi là 'canceled'/'interrupted'.`);
            }
            ttsState = 'idle'; 
            updateSpeechControlButton();
            currentUtterance = null;
        };
        
        try {
            speechSynthesis.speak(currentUtterance);
            console.log(`Đã gọi speechSynthesis.speak() cho chunk ${currentChunkIndex + 1}.`);
        } catch (e) {
            console.error(`Lỗi trực tiếp khi gọi speechSynthesis.speak() cho chunk ${currentChunkIndex + 1}:`, e);
            Swal.fire('Lỗi nghiêm trọng TTS', `Lỗi khi gọi hàm speak: ${e.message}`, 'error');
            ttsState = 'idle';
            updateSpeechControlButton();
        }
    }

    function handleSpeechControl() {
        console.log(`handleSpeechControl được gọi. Trạng thái hiện tại: ${ttsState}`);
        if (!speechControlButton) speechControlButton = document.getElementById('speechControlButton');

        if (typeof speechSynthesis === 'undefined') {
            Swal.fire('Lỗi TTS', 'Trình duyệt của bạn không hỗ trợ đọc văn bản.', 'error');
            return;
        }

        if (!ttsVoicesLoadedAtLeastOnce && ttsVoices.length === 0) {
            console.warn("Giọng đọc chưa tải, thử populate lại.");
            populateVoiceList(); 
            setTimeout(() => {
                if (!ttsVoicesLoadedAtLeastOnce && ttsVoices.length === 0) {
                    Swal.fire('TTS chưa sẵn sàng', 'Hệ thống TTS chưa sẵn sàng. Vui lòng thử lại sau giây lát.', 'warning');
                    updateSpeechControlButton(); 
                    return;
                }
                if (ttsState === 'idle' && document.getElementById('speechControlButton').textContent === 'Đọc') { 
                    console.log("Thử gọi lại handleSpeechControl sau khi populateVoiceList (nếu vẫn idle và nút là 'Đọc').");
                    handleSpeechControl();
                }
            }, 500); 
            return; 
        }
        
        if (ttsState === 'idle') { 
            console.log("Trạng thái 'idle': Bắt đầu đọc mới / Đọc lại từ đầu.");
            if(speechSynthesis.speaking || speechSynthesis.pending || speechSynthesis.paused) { 
                console.log(`Hủy bỏ việc đọc/chờ đọc/đang tạm dừng cũ. Speaking: ${speechSynthesis.speaking}, Pending: ${speechSynthesis.pending}, Paused: ${speechSynthesis.paused}`);
                speechSynthesis.cancel(); 
            }

            const textCollection = document.getElementById('collection');
            const fullText = textCollection.value;
            if (!fullText.trim()) {
                Swal.fire('Thông báo', 'Không có nội dung để đọc.', 'info');
                updateSpeechControlButton(); 
                return;
            }

            speechChunks = fullText.split(/\n\s*\n+/).map(chunk => chunk.trim()).filter(chunk => chunk !== '');
            if (speechChunks.length === 0 && fullText.trim() !== '') {
                speechChunks = [fullText.trim()];
            }
            if (speechChunks.length === 0) {
                 Swal.fire('Thông báo', 'Nội dung không hợp lệ để đọc.', 'info');
                 updateSpeechControlButton();
                 return;
            }
            
            console.log(`Đã chia văn bản thành ${speechChunks.length} chunk(s).`);
            currentChunkIndex = 0;
            ttsState = 'playing'; 
            speakNextChunk();

        } else if (ttsState === 'playing') { 
            console.log(`Trạng thái 'playing': Yêu cầu TẠM DỪNG đọc. Trước pause(): speaking=${speechSynthesis.speaking}, paused=${speechSynthesis.paused}`);
            speechSynthesis.pause();
            ttsState = 'paused'; 
            console.log(`Sau pause(): speaking=${speechSynthesis.speaking}, paused=${speechSynthesis.paused}. ttsState giờ là 'paused'.`);
        } else if (ttsState === 'paused') { 
            console.log(`Trạng thái 'paused': Yêu cầu TIẾP TỤC đọc. currentChunkIndex=${currentChunkIndex}, totalChunks=${speechChunks.length}. Trước resume(): speaking=${speechSynthesis.speaking}, paused=${speechSynthesis.paused}`);
            ttsState = 'playing'; 
            
            // Nếu speechSynthesis không còn ở trạng thái paused (ví dụ, utterance đã bị cancel ngầm)
            // hoặc nếu không còn gì đang speaking, thì chúng ta cần bắt đầu lại chunk hiện tại.
            if (!speechSynthesis.paused && !speechSynthesis.speaking && currentChunkIndex < speechChunks.length) {
                console.warn("Trạng thái của speechSynthesis không phải là 'paused' khi cố gắng resume, hoặc không có gì đang nói. Sẽ thử đọc lại chunk hiện tại.");
                speakNextChunk(); // Đọc lại chunk hiện tại
            } else if (speechSynthesis.paused) { // Chỉ gọi resume nếu trình duyệt thực sự đang paused
                speechSynthesis.resume();
                console.log(`Sau resume(): speaking=${speechSynthesis.speaking}, paused=${speechSynthesis.paused}. ttsState giờ là 'playing'.`);
            } else {
                 console.log("Không gọi resume vì speechSynthesis không ở trạng thái paused. Có thể đã kết thúc hoặc bị hủy. Thử speakNextChunk.");
                 speakNextChunk(); // Nếu không paused, có thể utterance đã kết thúc, thử chunk tiếp theo
            }
        }
        updateSpeechControlButton(); 
    }


    document.addEventListener('DOMContentLoaded', () => {
        logDivElement = document.getElementById('debugLog');
        console.log("Sự kiện DOMContentLoaded. Trang đã tải.");

        speechControlButton = document.getElementById('speechControlButton'); 

        if (typeof speechSynthesis !== 'undefined') {
            console.log("Trình duyệt có hỗ trợ speechSynthesis.");
            if (speechSynthesis.getVoices().length === 0) {
                console.log("Danh sách giọng đọc ban đầu trống, chờ onvoiceschanged.");
                speechSynthesis.onvoiceschanged = () => {
                    console.log("Sự kiện onvoiceschanged được kích hoạt (sau khi chờ).");
                    populateVoiceList();
                    speechSynthesis.onvoiceschanged = null; 
                };
            } else {
                console.log("Giọng đọc đã có sẵn khi DOMContentLoaded.");
                populateVoiceList();
            }
        } else {
            console.warn('Text-to-Speech không được hỗ trợ. Vô hiệu hóa nút TTS.');
            if(speechControlButton) speechControlButton.disabled = true;
        }
        
        // updateSpeechControlButton(); // Gọi ở cuối populateVoiceList rồi

        const savedUrls = localStorage.getItem(URLS_STORAGE_KEY);
        if (savedUrls) { document.getElementById('urls').value = savedUrls; }
        const urlsTextarea = document.getElementById('urls');
        urlsTextarea.addEventListener('input', () => { 
            localStorage.setItem(URLS_STORAGE_KEY, urlsTextarea.value); 
        });
        const collectionTextarea = document.getElementById('collection');
        collectionTextarea.addEventListener('input', updateSpeechControlButton);

    });

    // --- Các hàm cũ của trang (Dán vào đây) ---
    function getHistory() {
        const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
        return historyJson ? JSON.parse(historyJson) : [];
    }
    function addToHistory(url) {
        let history = getHistory();
        history = history.filter(item => item !== url);
        history.unshift(url);
        history = history.slice(0, MAX_HISTORY_SIZE);
        localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
    }
    async function showUrlHistory() {
        const history = getHistory();
        if (history.length === 0) {
            Swal.fire('Lịch sử trống', 'Chưa có URL nào được xử lý thành công.', 'info');
            return;
        }
        const inputOptions = {};
        history.forEach(url => { inputOptions[url] = url; });
        const { value: selectedUrl } = await Swal.fire({
            title: 'Lịch sử URL',
            input: 'select',
            inputOptions: inputOptions,
            inputPlaceholder: 'Chọn một URL từ lịch sử',
            showCancelButton: true,
            cancelButtonText: 'Hủy',
            confirmButtonText: 'Thêm vào ô nhập',
        });
        if (selectedUrl) {
            const urlsTextarea = document.getElementById('urls');
            urlsTextarea.value += (urlsTextarea.value.trim() ? '\n' : '') + selectedUrl;
            localStorage.setItem(URLS_STORAGE_KEY, urlsTextarea.value);
        }
    }
    async function fetchMultipleUrls() {
        const urlsText = document.getElementById('urls').value;
        const urls = urlsText.split('\n').filter(url => url.trim());
        if (urls.length === 0) {
            Swal.fire('Cảnh báo', 'Vui lòng nhập ít nhất một URL.', 'warning');
            return;
        }
        const progressBarFill = document.getElementById('progress-bar-fill');
        const progressText = document.getElementById('progress-text');
        const progressContainer = document.getElementById('progress-container');
        progressContainer.style.display = 'block';
        progressBarFill.style.width = '0%';
        progressText.textContent = '';
        let allContent = '';
        let successCount = 0;
        let failCount = 0;
        for (let i = 0; i < urls.length; i++) {
            const currentUrl = urls[i].trim();
            const progress = ((i + 1) / urls.length) * 100;
            progressBarFill.style.width = `${progress}%`;
            progressText.textContent = `Đang xử lý URL ${i + 1}/${urls.length}`;
            try {
                const proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(currentUrl);
                const response = await fetch(proxyUrl);
                if (!response.ok) {
                    let errorMsg = `Lỗi mạng khi fetch URL (${response.status})`;
                    try {
                        const errorData = await response.json();
                        if (errorData && errorData.contents) {
                            errorMsg = `Lỗi từ proxy (${response.status}): ${errorData.contents}`;
                        } else if (errorData && errorData.error) {
                            errorMsg = `Lỗi từ proxy (${response.status}): ${errorData.error}`;
                        }
                    } catch (e) { /* Bỏ qua lỗi parse json */ }
                    throw new Error(errorMsg);
                }
                const data = await response.json();
                if (data.contents && !data.contents.includes("Rate limit exceeded") && !data.contents.includes("Too Many Requests")) {
                    const content = await extractContent(data.contents);
                    if (content) {
                        allContent += content + '\n\n';
                        successCount++;
                        addToHistory(currentUrl);
                    } else {
                        failCount++;
                    }
                } else {
                    let reason = 'Proxy không trả về nội dung HTML';
                    if (data.contents && (data.contents.includes("Rate limit exceeded") || data.contents.includes("Too Many Requests"))) {
                        reason = 'Trang đích chặn do quá nhiều yêu cầu (Rate limit)';
                    } else if (data.status && data.status.http_code && data.status.http_code !== 200) {
                        reason = `Trang đích trả về lỗi HTTP ${data.status.http_code}`;
                    }
                    failCount++;
                }
            } catch (error) {
                failCount++;
            }
            await new Promise(resolve => setTimeout(resolve, 300));
        }
        document.getElementById('collection').value = allContent.trim();
        updateSpeechControlButton(); 
        progressContainer.style.display = 'none';
        Swal.fire({
            icon: failCount > 0 ? (successCount > 0 ? 'warning' : 'error') : 'success',
            title: 'Hoàn thành!',
            text: `Thành công: ${successCount} URL\nThất bại: ${failCount} URL`,
        });
    }
    function processText(text) {
        text = text.replace(/\r\n/g, '\n');
        text = text.replace(/[ \t]*\n[ \t]*/g, '\n');
        text = text.replace(/\n{3,}/g, '\n\n');
        text = text.replace(/(?<![\.\?\!"”\)\]\}…])\s*\n(?!\s*[-–—"“‘\(\[\{A-Z0-9\d])/g, ' ');
        text = text.replace(/([\.!\?…])([ \t]*)(?![\n"”’\)\]\}])/g, '$1\n');
        text = text.replace(/^\s*([-–—])\s*/gm, '\n$1 ');
        text = text.replace(/([-–—])([^\s])/g, '$1 $2');
        text = text.trim();
        return text;
    }
    async function extractContent(html) {
        if (!html) return '';
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const truyenTitleEl = doc.querySelector('.truyen-title a, .breadcrumb li:nth-last-child(2) a, h1.breadcrumb-title');
        const chapterTitleEl = doc.querySelector('.chapter-title, h1.entry-title, .h1 DBMana-chapter');
        let title = '';
        const truyenTitle = truyenTitleEl ? truyenTitleEl.textContent.trim() : '';
        const chapterTitle = chapterTitleEl ? chapterTitleEl.textContent.trim() : '';
        if (truyenTitle && chapterTitle) {
            title = `${truyenTitle.toUpperCase()} - ${chapterTitle.toUpperCase()}\n\n`;
        } else if (chapterTitle) {
            title = `${chapterTitle.toUpperCase()}\n\n`;
        }
        let chapterContentElement = doc.querySelector('#chapter-c, .entry-content, .reading-content, #content, article .text-left, #vung_doc, .chapter-content');
        if (!chapterContentElement) {
            return '';
        }
        const selectorsToRemove = [
            '.ads-responsive', '.ads-chapter-bottom-lien-quan', 'script', 'style',
            'iframe', 'ins', '.hidden', '[style*="display:none"]', '[style*="display: none"]',
            '#comment', '.wpd-comment-thread', '.nav-links', '.chapter-nav',
            'a[href*="truyenfull"]', 'a[href*="nettruyen"]', 'a[href*="metruyenchu"]',
            'div[class*="google"]', 'div[id*="google"]',
            'div[class*="ads"]', 'div[id*="ads"]',
            'button', 'input', 'select', 'textarea',
            '.interact-area', '#report-chapter-button', '.footer', 'footer',
            '.notes', '.navigation-panel', '.chapter-selection', '.fb-comments', '.comments-area'
        ];
        chapterContentElement.querySelectorAll(selectorsToRemove.join(', ')).forEach(el => el.remove());
        let content = '';
        const paragraphs = chapterContentElement.querySelectorAll('p');
        if (paragraphs.length > 10) {
            paragraphs.forEach(p => {
                const pText = p.textContent.replace(/\s+/g, ' ').trim();
                if (pText && !pText.toLowerCase().includes("truyện được sưu tầm") && !pText.toLowerCase().includes("nguồn tại")) {
                    content += pText + '\n\n';
                }
            });
        } else {
            const walker = doc.createTreeWalker(
                chapterContentElement,
                NodeFilter.SHOW_TEXT,
                { acceptNode: function(node) {
                    if (!node.parentNode || ['SCRIPT', 'STYLE', 'NOSCRIPT'].includes(node.parentNode.tagName) || !node.textContent.trim()) {
                        return NodeFilter.FILTER_REJECT;
                    }
                    return NodeFilter.FILTER_ACCEPT;
                  }
                }
            );
            let node;
            while(node = walker.nextNode()) {
                content += node.textContent.trim() + ' ';
            }
            content = content.replace(/\s+/g, ' ');
        }
        const linesToRemove = [
            /truyện được cập nhật tại .*/i, /nguồn truyện: .*/i, /đọc truyện tại .*/i,
            /mời bạn đọc thêm nhiều truyện hay tại .*/i, /hãy bình chọn cho truyện/i,
            /.*(like|share|vote).*ủng hộ.*/i, /^ps:.*$/i, /^\(.*\)$/
        ];
        let lines = content.split('\n');
        lines = lines.filter(line => {
            const trimmedLine = line.trim();
            if (!trimmedLine) return false;
            for (const regex of linesToRemove) {
                if (regex.test(trimmedLine)) return false;
            }
            return true;
        });
        content = lines.join('\n');
        content = processText(content.trim());
        return title + content;
    }
    function generateNextUrls() {
        const urlsText = document.getElementById('urls').value.trim();
        if (!urlsText) {
            Swal.fire('Cảnh báo', 'Vui lòng nhập ít nhất một URL.', 'warning');
            return;
        }
        const lines = urlsText.split('\n').filter(line => line.trim());
        const lastUrl = lines[lines.length - 1];
        const chapterMatch = lastUrl.match(/(?:chuong|chapter)-(\d+)/i);
        if (!chapterMatch || chapterMatch.length < 2) {
            Swal.fire('Lỗi', 'Không tìm thấy mẫu số chương (ví dụ: chuong-123 hoặc chapter-123) trong URL cuối cùng.', 'error');
            return;
        }
        const chapterNum = parseInt(chapterMatch[1]);
        const prefix = chapterMatch[0].split('-')[0];
        const baseUrl = lastUrl.substring(0, chapterMatch.index);
        const suffix = lastUrl.substring(chapterMatch.index + chapterMatch[0].length);
        let newUrls = '';
        for (let i = 1; i <= 3; i++) {
            const nextChapter = chapterNum + i;
            newUrls += `${baseUrl}${prefix}-${nextChapter}${suffix}\n`;
        }
        const urlsTextarea = document.getElementById('urls');
        urlsTextarea.value = urlsText + '\n' + newUrls.trim();
        localStorage.setItem(URLS_STORAGE_KEY, urlsTextarea.value);
    }
    function replaceWithNextUrls() {
        const urlsText = document.getElementById('urls').value.trim();
        if (!urlsText) {
            Swal.fire('Cảnh báo', 'Vui lòng nhập ít nhất một URL.', 'warning');
            return;
        }
        const lines = urlsText.split('\n').filter(line => line.trim());
        const lastUrl = lines[lines.length - 1];
        const chapterMatch = lastUrl.match(/(?:chuong|chapter)-(\d+)/i);
        if (!chapterMatch || chapterMatch.length < 2) {
            Swal.fire('Lỗi', 'Không tìm thấy mẫu số chương (ví dụ: chuong-123 hoặc chapter-123) trong URL cuối cùng.', 'error');
            return;
        }
        const chapterNum = parseInt(chapterMatch[1]);
        const prefix = chapterMatch[0].split('-')[0];
        const baseUrl = lastUrl.substring(0, chapterMatch.index);
        const suffix = lastUrl.substring(chapterMatch.index + chapterMatch[0].length);
        let newUrls = '';
        for (let i = 1; i <= 4; i++) {
            const nextChapter = chapterNum + i;
            newUrls += `${baseUrl}${prefix}-${nextChapter}${suffix}\n`;
        }
        const urlsTextarea = document.getElementById('urls');
        urlsTextarea.value = newUrls.trim();
        localStorage.setItem(URLS_STORAGE_KEY, urlsTextarea.value);
    }
    function clearUrls() {
        const urlsTextarea = document.getElementById('urls');
        urlsTextarea.value = '';
        localStorage.removeItem(URLS_STORAGE_KEY);
    }
    async function copyToClipboard() {
        const text = document.getElementById('collection').value;
        if (!text.trim()) {
            Swal.fire('Thông báo', 'Không có nội dung để sao chép.', 'info');
            return;
        }
        try {
            await navigator.clipboard.writeText(text);
            Swal.fire('Đã sao chép!', 'Nội dung đã được sao chép vào clipboard', 'success');
        } catch (err) {
            Swal.fire({
                icon: 'error',
                title: 'Lỗi sao chép tự động',
                text: 'Không thể tự động sao chép. Vui lòng chọn thủ công (Ctrl+A hoặc Cmd+A để chọn hết, sau đó Ctrl+C hoặc Cmd+C để sao chép).',
            });
        }
    }
    </script>
</body>
</html>
