<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern TTS Reader with Translation</title>
    <script src="https://code.responsivevoice.org/responsivevoice.js?key=YOUR_API_KEY"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <style>
        :root {
            --primary-50: #f0f9ff;
            --primary-100: #e0f2fe;
            --primary-200: #bae6fd;
            --primary-300: #7dd3fc;
            --primary-400: #38bdf8;
            --primary-500: #0ea5e9;
            --primary-600: #0284c7;
            --primary-700: #0369a1;
            --primary-800: #075985;
            --primary-900: #0c4a6e;

            --neutral-50: #f8fafc;
            --neutral-100: #f1f5f9;
            --neutral-200: #e2e8f0;
            --neutral-300: #cbd5e1;
            --neutral-400: #94a3b8;
            --neutral-500: #64748b;
            --neutral-600: #475569;
            --neutral-700: #334155;
            --neutral-800: #1e293b;
            --neutral-900: #0f172a;

            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --info: #3b82f6;

            --transition-fast: 150ms ease-in-out;
            --transition-normal: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;

            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--neutral-100);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--neutral-300);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--neutral-400);
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--neutral-50);
            color: var(--neutral-800);
            line-height: 1.6;
        }

        .card {
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
            transition: var(--transition-normal);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
        }

        input[type="text"],
        input[type="url"],
        textarea,
        select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--neutral-200);
            border-radius: 8px;
            background-color: white;
            transition: var(--transition-fast);
        }

        input[type="text"]:focus,
        input[type="url"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--primary-400);
            box-shadow: 0 0 0 3px var(--primary-100);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            transition: var(--transition-fast);
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .btn-primary {
            background-color: var(--primary-600);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-700);
        }

        .btn-secondary {
            background-color: var(--neutral-100);
            color: var(--neutral-700);
        }

        .btn-secondary:hover {
            background-color: var(--neutral-200);
        }

        .player-controls {
            display: flex;
            gap: 0.5rem;
            padding: 1rem;
            background: white;
            border-radius: 12px;
            box-shadow: var(--shadow);
        }

        .control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--neutral-100);
            color: var(--neutral-700);
            transition: var(--transition-fast);
        }

        .control-btn:hover {
            background: var(--neutral-200);
            transform: scale(1.05);
        }

        .control-btn.active {
            background: var(--primary-600);
            color: white;
        }

        .content-image {
            width: 100%;
            margin: 1rem 0;
            position: relative;
            background: var(--neutral-50);
            border-radius: 8px;
            overflow: hidden;
        }

        .content-image img {
            width: 100%;
            height: auto;
            display: block;
            transition: var(--transition-normal);
        }

        .content-image.loading::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--neutral-100);
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .content-image.error {
            padding: 1rem;
            text-align: center;
            background: var(--neutral-100);
        }

        .text-error {
            color: var(--error);
            font-size: 0.875rem;
        }

        .sidebar {
            position: relative;
        }

        .sticky-controls {
            position: sticky;
            top: 1rem;
            z-index: 10;
            background: inherit;
            border-radius: inherit;
        }

        .sidebar-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }

        .sidebar-content.expanded {
            max-height: 500px;
        }

        #sidebarToggle {
            transition: all 0.3s ease;
        }

        #sidebarToggle .toggle-icon {
            transition: transform 0.3s ease;
        }

        #sidebarToggle.collapsed .toggle-icon {
            transform: rotate(180deg);
        }

        .content-item {
            padding: 0.75rem;
            margin: 0.5rem 0;
            border-radius: 0.5rem;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        .content-item:hover {
            background-color: var(--neutral-100);
        }

        .content-item.active {
            background-color: var(--primary-600);
            border-left-color: var(--primary-800);
            color: white;
        }

        .editing .content-item {
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        .editing .content-item.active {
            background-color: var(--primary-800);
            border-left-color: var(--primary-400);
            color: white;
        }

        .content-item[data-tag^="H"] {
            font-weight: 600;
        }

        .content-item[data-tag="H1"] { font-size: 1.5rem; margin-left: 0; }
        .content-item[data-tag="H2"] { font-size: 1.25rem; margin-left: 1rem; }
        .content-item[data-tag="H3"] { font-size: 1.1rem; margin-left: 2rem; }
        .content-item[data-tag="H4"] { font-size: 1rem; margin-left: 3rem; }
        .content-item[data-tag="H5"] { font-size: 0.9rem; margin-left: 4rem; }
        .content-item[data-tag="H6"] { font-size: 0.8rem; margin-left: 5rem; }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: white;
                padding: 1rem;
                border-radius: 20px 20px 0 0;
                box-shadow: var(--shadow-lg);
                z-index: 50;
            }

            .sticky-controls {
                position: relative;
                top: 0;
            }
        }

        @media (prefers-color-scheme: dark) {
            body {
                background-color: var(--neutral-900);
                color: var(--neutral-100);
            }

            .card {
                background: var(--neutral-800);
            }

            input[type="text"],
            input[type="url"],
            textarea,
            select {
                background-color: var(--neutral-800);
                border-color: var(--neutral-700);
                color: var(--neutral-100);
            }

            .btn-secondary {
                background-color: var(--neutral-700);
                color: var(--neutral-200);
            }

            .btn-secondary:hover {
                background-color: var(--neutral-600);
            }

            .control-btn {
                background: var(--neutral-700);
                color: var(--neutral-200);
            }

            .control-btn:hover {
                background: var(--neutral-600);
            }

            .content-item:hover {
                background-color: var(--neutral-700);
            }

            .content-item.active {
                background-color: var(--primary-800);
                border-left-color: var(--primary-400);
            }

            .content-image.loading::before {
                background: var(--neutral-700);
            }

            .content-image.error {
                background: var(--neutral-800);
            }
        }
    </style>
</head>
<body>
    <div class="min-h-screen p-4 md:p-6 lg:p-8">
        <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-[300px,1fr] gap-6">
            <!-- Sidebar -->
            <aside class="sidebar card p-4">
                <div class="sticky-controls">
                    <!-- Image toggle -->
                    <div class="mb-4">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="showImages" checked class="accent-primary-600">
                            <span>Show Images</span>
                        </label>
                    </div>

                    <div class="player-controls mb-2">
                        <button onclick="startReading()" id="playButton" class="control-btn" aria-label="Play">
                            <i class="ri-play-fill text-xl"></i>
                        </button>
                        <button onclick="pauseReading()" id="pauseButton" class="control-btn" aria-label="Pause">
                            <i class="ri-pause-fill text-xl"></i>
                        </button>
                        <button onclick="resumeReading()" id="resumeButton" class="control-btn" aria-label="Resume">
                            <i class="ri-play-fill text-xl"></i>
                        </button>
                        <button onclick="stopReading()" id="stopButton" class="control-btn" aria-label="Stop">
                            <i class="ri-stop-fill text-xl"></i>
                        </button>
                        <div class="flex-1 flex items-center px-4">
                            <div class="w-full bg-neutral-200 dark:bg-neutral-700 rounded-full h-2">
                                <div id="progressBar" class="bg-primary-600 h-2 rounded-full transition-all duration-300"></div>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-center">
                        <i id="sidebarIndicator" class="ri-arrow-down-s-line text-2xl text-neutral-400"></i>
                    </div>
                </div>

                <!-- Collapsible settings -->
                <div id="sidebarContent" class="sidebar-content mt-2">
                    <div class="mb-4">
                        <h3 class="text-lg font-semibold mb-2">Input Mode</h3>
                        <div class="flex gap-4">
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="mode" value="text" class="accent-primary-600">
                                <span>Text</span>
                            </label>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="mode" value="html" class="accent-primary-600">
                                <span>HTML</span>
                            </label>
                            <label class="flex items-center gap-2 cursor-pointer">
<input type="radio" name="mode" value="url" checked class="accent-primary-600">
                                <span>URL</span>
                            </label>
                        </div>
                    </div>

                    <div class="mb-4">
                        <h3 class="text-lg font-semibold mb-2">Voice Settings</h3>
                        <div class="space-y-3">
                            <div>
                                <label class="flex justify-between mb-1">
                                    <span>Speed</span>
                                    <span id="rateValue">1.0</span>
                                </label>
                                <input type="range" id="rate" min="0.5" max="1.5" step="0.1" value="1"
                                    class="w-full accent-primary-600">
                            </div>
                            <div>
                                <label class="flex justify-between mb-1">
                                    <span>Pitch</span>
                                    <span id="pitchValue">1.0</span>
                                </label>
                                <input type="range" id="pitch" min="0.5" max="2" step="0.1" value="1"
                                    class="w-full accent-primary-600">
                            </div>
                        </div>
                    </div>

                    <div class="p-3 bg-neutral-100 dark:bg-neutral-700 rounded-lg">
                        <div id="stats" class="text-sm space-y-1">
                            <!-- Stats content -->
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Main content -->
            <main class="space-y-6">
                <div class="card p-4">
                    <div id="textInput" class="hidden space-y-4">
                        <textarea id="inputText" rows="6" placeholder="Enter your text or HTML here..."
                            class="w-full resize-y"></textarea>
                        <button onclick="processInput()" class="btn btn-primary">
                            <i class="ri-play-circle-line"></i>
                            Process Content
                        </button>
                    </div>

                    <div id="urlInput" class="space-y-4">
                        <div class="flex gap-4">
                            <input type="url" id="urlField" placeholder="Enter URL (e.g., https://example.com)">
                            <button onclick="fetchUrl()" class="btn btn-primary">
                                <i class="ri-download-cloud-line"></i>
                                Fetch
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Content panels -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Source panel -->
                    <div class="card">
                        <div class="border-b border-neutral-200 dark:border-neutral-700">
                            <div class="flex items-center justify-between p-4">
                                <h2 class="text-lg font-semibold">Original Text</h2>
                                <div class="flex items-center gap-4">
                                    <select id="sourceLang" class="w-40" onchange="updateVoiceOptions('source')">
                                        <option value="vi">Tiếng Việt</option>
                                        <option value="en">English</option>
                                    </select>
                                    <select id="sourceVoice" class="w-40"></select>
                                    <button onclick="toggleEdit('source')" class="btn btn-secondary" id="editButton">
                                        <i class="ri-edit-line"></i>
                                        Edit
                                    </button>
                                    <button onclick="saveEdit('source')" class="btn btn-primary hidden" id="saveButton">
                                        <i class="ri-save-line"></i>
                                        Save
                                    </button>
                                    <button onclick="toggleReading('source')" class="btn btn-secondary">
                                        <i class="ri-volume-up-line"></i>
                                        Read Source
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div id="sourceContent" class="p-4 h-[600px] overflow-y-auto"></div>
                    </div>

                    <!-- Target panel -->
                    <div class="card">
                        <div class="border-b border-neutral-200 dark:border-neutral-700">
                            <div class="flex items-center justify-between p-4">
                                <h2 class="text-lg font-semibold">Translation</h2>
                                <div class="flex items-center gap-4">
                                    <select id="targetLang" class="w-40" onchange="updateVoiceOptions('target')">
                                        <option value="en">English</option>
                                        <option value="vi">Tiếng Việt</option>
                                    </select>
                                    <select id="targetVoice" class="w-40"></select>
                                    <button onclick="toggleReading('target')" class="btn btn-secondary">
                                        <i class="ri-volume-up-line"></i>
                                        Read Translation
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div id="targetContent" class="p-4 h-[600px] overflow-y-auto"></div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Status toast -->
    <div id="status" class="fixed bottom-4 right-4 p-4 rounded-lg shadow-lg transition-all duration-300 opacity-0"></div>

    <!-- Loading overlay -->
    <div id="loading" class="fixed inset-0 bg-black/50 flex items-center justify-center hidden">
        <div class="bg-white dark:bg-neutral-800 p-6 rounded-lg shadow-xl flex items-center gap-4">
            <div class="animate-spin w-6 h-6 border-4 border-primary-600 border-t-transparent rounded-full"></div>
            <span class="text-lg">Processing...</span>
        </div>
    </div>

    <script>
        // State management
        const state = {
            currentMode: 'url',
            sourceQueue: [],
            targetQueue: [],
            currentIndex: -1,
            isReading: false,
            isPaused: false,
            currentLanguage: 'source',
            contentLoaded: false,
            showImages: true,
            baseUrl: ''
        };

        // Document ready handler
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
            setupEventListeners();
        });

        function initializeApp() {
            updateVoiceOptions('source');
            updateVoiceOptions('target');
            updateStats();
            showToast('Ready to use!', 'info');

            const sidebarContent = document.getElementById('sidebarContent');
            sidebarContent.classList.add('expanded');
            document.getElementById('sidebarIndicator').style.transform = 'rotate(180deg)';
        }

        function setupEventListeners() {
            setupScrollHandling();
            setupInputListeners();
            setupKeyboardShortcuts();
            setupPanelSync();
            setupImageToggle();
        }

        // URL resolution helper
        function resolveUrl(url) {
            if (!url) return '';
            
            // Keep base64 URLs as is
            if (url.startsWith('data:')) {
                return url;
            }
            
            try {
                return new URL(url, state.baseUrl).href;
            } catch (e) {
                return url;
            }
        }

        // Voice handling
        function updateVoiceOptions(type) {
            const lang = document.getElementById(type + 'Lang').value;
            const voiceSelect = document.getElementById(type + 'Voice');
            
            const voices = {
                vi: [
                    { value: "Vietnamese Male", label: "Giọng Nam (Mặc định)", default: true },
                    { value: "Vietnamese Female", label: "Giọng Nữ" }
                ],
                en: [
                    { value: "UK English Male", label: "UK Male (Default)", default: true },
                    { value: "UK English Female", label: "UK Female" },
                    { value: "US English Male", label: "US Male" },
                    { value: "US English Female", label: "US Female" }
                ]
            };

            voiceSelect.innerHTML = voices[lang]
                .map(voice => `<option value="${voice.value}" ${voice.default ? 'selected' : ''}>${voice.label}</option>`)
                .join('');
        }

        // Content processing
        async function processInput() {
            const input = document.getElementById('inputText').value.trim();
            if (!input) {
                showToast('Please enter some content', 'error');
                return;
            }

            showLoading(true);
            try {
                if (state.currentMode === 'text') {
                    await processTextContent(input);
                } else {
                    await parseContent(input);
                }
                
                state.contentLoaded = true;
                updateStats();
                showToast('Content processed successfully', 'success');
            } catch (error) {
                console.error('Processing error:', error);
                showToast(error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function processTextContent(text) {
            if (!text.trim()) {
                throw new Error('Content is empty');
            }

            const paragraphs = text
                .split(/\n\n+/)
                .filter(p => p.trim())
                .map(p => ({ text: p.trim(), tag: 'P' }));

            clearContent();

            for (const paragraph of paragraphs) {
                state.sourceQueue.push({ 
                    type: 'text',
                    text: paragraph.text,
                    tag: paragraph.tag
                });
                appendContentItem(state.sourceQueue[state.sourceQueue.length - 1], 
                                state.sourceQueue.length - 1, 'source');

                try {
                    const sourceLang = document.getElementById('sourceLang').value;
                    const targetLang = document.getElementById('targetLang').value;
                    const translatedText = await translate(paragraph.text, sourceLang, targetLang);
                    
                    if (translatedText) {
                        state.targetQueue.push({ 
                            type: 'text',
                            text: translatedText,
                            tag: paragraph.tag
                        });
                        appendContentItem(state.targetQueue[state.targetQueue.length - 1], 
                                       state.targetQueue.length - 1, 'target');
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    showToast(`Translation failed for paragraph ${state.sourceQueue.length}`, 'error');
                }
            }
        }

        // URL fetching
        async function fetchUrl() {
            const url = document.getElementById('urlField').value.trim();
            if (!url) {
                showToast('Please enter a valid URL', 'error');
                return;
            }

            showLoading(true);
            try {
                state.baseUrl = url;
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                const response = await fetch(proxyUrl);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch content');
                }

                const html = await response.text();
                await parseContent(html);
                showToast('Content fetched successfully', 'success');
            } catch (error) {
                showToast(error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function parseContent(content) {
            if (!content.trim()) {
                showToast('Content is empty', 'error');
                return;
            }

            showLoading(true);
            try {
                state.sourceQueue = [];
                state.targetQueue = [];
                state.contentLoaded = false;

                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');
                clearContent();

                doc.querySelectorAll('sup').forEach(sup => sup.remove());
                const elements = doc.querySelectorAll('h1, h2, h3, h4, h5, h6, p, img');

                for (const el of elements) {
                    if (el.tagName === 'IMG' && state.showImages) {
                        const imgSrc = el.getAttribute('src');
                        // Handle both regular URLs and base64 images
                        const resolvedSrc = imgSrc.startsWith('data:') ? imgSrc : resolveUrl(imgSrc);
                        const imgAlt = el.getAttribute('alt') || '';
                        
                        const sourceItem = { 
                            type: 'image',
                            src: resolvedSrc,
                            alt: imgAlt,
                            tag: 'IMG'
                        };
                        
                        state.sourceQueue.push(sourceItem);
                        appendContentItem(sourceItem, state.sourceQueue.length - 1, 'source');
                        
                        state.targetQueue.push({...sourceItem});
                        appendContentItem(sourceItem, state.targetQueue.length - 1, 'target');
                    } else {
                        const text = el.textContent.trim();
                        if (!text) continue;

                        const sourceItem = { 
                            type: 'text',
                            text,
                            tag: el.tagName
                        };
                        
                        state.sourceQueue.push(sourceItem);
                        appendContentItem(sourceItem, state.sourceQueue.length - 1, 'source');

                        try {
                            const sourceLang = document.getElementById('sourceLang').value;
                            const targetLang = document.getElementById('targetLang').value;
                            const translatedText = await translate(text, sourceLang, targetLang);
                            
                            if (translatedText) {
                                const targetItem = { 
                                    type: 'text',
                                    text: translatedText,
                                    tag: el.tagName
                                };
                                state.targetQueue.push(targetItem);
                                appendContentItem(targetItem, state.targetQueue.length - 1, 'target');
                            }
                        } catch (error) {
                            console.error('Translation error:', error);
                            showToast(`Translation failed for section ${state.sourceQueue.length}`, 'error');
                        }
                    }
                }

                state.contentLoaded = true;
                updateStats();
                showToast('Content parsed successfully', 'success');
            } catch (error) {
                console.error('Parsing error:', error);
                showToast('Error parsing content: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Translation function
        // Translation function
async function translate(text, source, target) {
    try {
        const CHUNK_SIZE = 1000;
        // Phân đoạn text thành các chunks có kích thước tối đa là CHUNK_SIZE
        const chunks = text.match(new RegExp(`.{1,${CHUNK_SIZE}}`, 'g')) || [];
        
        let translatedText = '';
        for (const chunk of chunks) {
            const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${source}&tl=${target}&dt=t&q=${encodeURIComponent(chunk)}`;
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            translatedText += data[0].map(x => x[0]).join('');
            await new Promise(resolve => setTimeout(resolve, 300)); // Rate limiting
        }
        
        return translatedText;
    } catch (error) {
        console.error('Translation error:', error);
        throw new Error('Translation failed. Please try again.');
    }
}

        function appendContentItem(item, index, type) {
            const container = document.getElementById(`${type}Content`);
            const div = document.createElement('div');

            if (item.type === 'image' && state.showImages) {
                div.className = 'content-image loading';
                div.dataset.index = index;
                
                const img = document.createElement('img');
                img.src = item.src;
                img.alt = item.alt;
                img.loading = 'lazy';
                
                // Special handling for base64 images
                if (item.src.startsWith('data:')) {
                    img.onerror = () => {
                        div.classList.remove('loading');
                        div.classList.add('error');
                        div.innerHTML = `<p class="text-error">Invalid base64 image format</p>`;
                    };
                }
                
                img.onload = () => {
                    div.classList.remove('loading');
                    // Match width to container
                    img.style.width = '100%';
                    img.style.height = 'auto';
                };
                
                img.onerror = () => {
                    div.classList.remove('loading');
                    div.classList.add('error');
                    if (item.src.startsWith('data:')) {
                        div.innerHTML = `<p class="text-error">Failed to load base64 image</p>`;
                    } else {
                        div.innerHTML = `<p class="text-error">Failed to load image: ${item.alt}</p>`;
                    }
                };
                
                div.appendChild(img);
            } else {
                div.className = 'content-item';
                div.dataset.tag = item.tag;
                div.dataset.index = index;
                div.textContent = item.text;
                div.onclick = () => startReadingFrom(index, type);
            }
            
            container.appendChild(div);
        }

        function startReadingFrom(index, language) {
            if (!state.contentLoaded) return;
            state.currentLanguage = language;
            state.currentIndex = index;
            startReading();
        }

        function showToast(message, type = 'info') {
            const status = document.getElementById('status');
            const colors = {
                success: 'bg-green-500',
                error: 'bg-red-500',
                info: 'bg-blue-500'
            };

            status.className = `fixed bottom-4 right-4 p-4 rounded-lg shadow-lg text-white ${colors[type]} transition-all duration-300`;
            status.textContent = message;
            status.style.opacity = '1';

            if (type !== 'error') {
                setTimeout(() => {
                    status.style.opacity = '0';
                }, 3000);
            }
        }

        function showLoading(show = true) {
            document.getElementById('loading').style.display = show ? 'flex' : 'none';
        }

        function clearContent() {
            state.sourceQueue = [];
            state.targetQueue = [];
            document.getElementById('sourceContent').innerHTML = '';
            document.getElementById('targetContent').innerHTML = '';
        }

        // Setup event listeners
        function setupScrollHandling() {
            const sidebarContent = document.getElementById('sidebarContent');
            const sidebarIndicator = document.getElementById('sidebarIndicator');
            let lastScrollTop = 0;

            window.addEventListener('scroll', () => {
                const st = window.pageYOffset || document.documentElement.scrollTop;
                
                if (st > lastScrollTop && st > 100) {
                    sidebarContent.classList.remove('expanded');
                    sidebarIndicator.style.transform = 'rotate(0deg)';
                } else if (st < lastScrollTop) {
                    sidebarContent.classList.add('expanded');
                    sidebarIndicator.style.transform = 'rotate(180deg)';
                }
                
                lastScrollTop = st <= 0 ? 0 : st;
            });
        }

        function setupInputListeners() {
            document.getElementById('rate').addEventListener('input', function() {
                document.getElementById('rateValue').textContent = this.value;
            });
            
            document.getElementById('pitch').addEventListener('input', function() {
                document.getElementById('pitchValue').textContent = this.value;
            });
            
            document.querySelectorAll('input[name="mode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    switchMode(this.value);
                });
            });
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                if (event.target.tagName === 'TEXTAREA' || event.target.tagName === 'INPUT') {
                    return;
                }

                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        if (state.isReading) {
                            if (state.isPaused) {
                                resumeReading();
                            } else {
                                pauseReading();
                            }
                        } else {
                            startReading();
                        }
                        break;
                    case 'Escape':
                        stopReading();
                        break;
                }
            });
        }

        function setupPanelSync() {
            const sourcePanel = document.getElementById('sourceContent');
            const targetPanel = document.getElementById('targetContent');

            sourcePanel.addEventListener('scroll', () => {
                targetPanel.scrollTop = sourcePanel.scrollTop;
            });

            targetPanel.addEventListener('scroll', () => {
                sourcePanel.scrollTop = targetPanel.scrollTop;
            });
        }

        function setupImageToggle() {
            document.getElementById('showImages').addEventListener('change', function() {
                state.showImages = this.checked;
                if (state.contentLoaded) {
                    const sourcePanel = document.getElementById('sourceContent');
                    parseContent(sourcePanel.innerHTML);
                }
            });
        }







function initializeApp() {
    // Khởi tạo voice options
    updateVoiceOptions('source');
    updateVoiceOptions('target');
    
    // Khởi tạo stats với giá trị mặc định
    initializeStats();
    
    // Hiển thị sidebar mở rộng
    const sidebarContent = document.getElementById('sidebarContent');
    sidebarContent.classList.add('expanded');
    document.getElementById('sidebarIndicator').style.transform = 'rotate(180deg)';
    
    // Thông báo sẵn sàng
    showToast('Ready to use!', 'info');
}

function initializeStats() {
    const stats = document.getElementById('stats');
    stats.innerHTML = `
        <div class="flex justify-between">
            <span>Text Sections:</span>
            <span class="font-medium">0</span>
        </div>
        <div class="flex justify-between">
            <span>Images:</span>
            <span class="font-medium">0</span>
        </div>
        <div class="flex justify-between">
            <span>Words:</span>
            <span class="font-medium">0</span>
        </div>
        <div class="flex justify-between">
            <span>Est. Time:</span>
            <span class="font-medium">0s</span>
        </div>
        <div class="flex justify-between">
            <span>Current:</span>
            <span class="font-medium">0/0</span>
        </div>
    `;
}

function updateStats() {
    if (!state.sourceQueue) return; // Kiểm tra nếu chưa có dữ liệu
    
    const stats = document.getElementById('stats');
    const totalSections = state.sourceQueue.filter(item => item.type === 'text').length;
    const totalImages = state.sourceQueue.filter(item => item.type === 'image').length;
    const totalWords = state.sourceQueue
        .filter(item => item.type === 'text')
        .reduce((acc, item) => acc + item.text.split(/\s+/).length, 0);
    const estimatedTime = Math.ceil(totalWords * 0.3);

    stats.innerHTML = `
        <div class="flex justify-between">
            <span>Text Sections:</span>
            <span class="font-medium">${totalSections}</span>
        </div>
        <div class="flex justify-between">
            <span>Images:</span>
            <span class="font-medium">${totalImages}</span>
        </div>
        <div class="flex justify-between">
            <span>Words:</span>
            <span class="font-medium">${totalWords}</span>
        </div>
        <div class="flex justify-between">
            <span>Est. Time:</span>
            <span class="font-medium">${estimatedTime}s</span>
        </div>
        <div class="flex justify-between">
            <span>Current:</span>
            <span class="font-medium">${state.currentIndex + 1}/${state.sourceQueue.length}</span>
        </div>
    `;
}


// Edit functionality
function toggleEdit(type) {
    const content = document.getElementById(`${type}Content`);
    const editButton = document.getElementById('editButton');
    const saveButton = document.getElementById('saveButton');
    
    if (!content.contentEditable || content.contentEditable === 'false') {
        // Enable editing
        content.contentEditable = true;
        content.focus();
        content.classList.add('editing');
        editButton.classList.add('hidden');
        saveButton.classList.remove('hidden');
        // Add visual feedback
        content.style.padding = '1rem';
        content.style.border = '2px solid var(--primary-400)';
    } else {
        // Disable editing without saving
        disableEdit(content, editButton, saveButton);
    }
}

function saveEdit(type) {
    const content = document.getElementById(`${type}Content`);
    const editButton = document.getElementById('editButton');
    const saveButton = document.getElementById('saveButton');
    
    // Disable editing
    disableEdit(content, editButton, saveButton);
    
    // Update source queue
    const sections = Array.from(content.getElementsByClassName('content-item'));
    state.sourceQueue = sections
        .filter(section => section.textContent.trim())
        .map(section => ({
            type: 'text',
            text: section.textContent.trim(),
            tag: section.dataset.tag
        }));
    
    // Retranslate content
    translateEditedContent();
    
    showToast('Changes saved and content re-translated', 'success');
}

function disableEdit(content, editButton, saveButton) {
    content.contentEditable = false;
    content.classList.remove('editing');
    content.style.padding = '';
    content.style.border = '';
    editButton.classList.remove('hidden');
    saveButton.classList.add('hidden');
}

async function translateEditedContent() {
    const sourceLang = document.getElementById('sourceLang').value;
    const targetLang = document.getElementById('targetLang').value;
    const targetContent = document.getElementById('targetContent');
    
    // Clear target content
    state.targetQueue = [];
    targetContent.innerHTML = '';
    
    // Translate all text items
    for (let i = 0; i < state.sourceQueue.length; i++) {
        const item = state.sourceQueue[i];
        if (item.type === 'text') {
            try {
                const translatedText = await translate(item.text, sourceLang, targetLang);
                if (translatedText) {
                    const targetItem = { 
                        type: 'text',
                        text: translatedText,
                        tag: item.tag
                    };
                    state.targetQueue.push(targetItem);
                    appendContentItem(targetItem, i, 'target');
                }
            } catch (error) {
                console.error('Translation error:', error);
                showToast(`Translation failed for section ${i + 1}`, 'error');
            }
        }
    }
    
    updateStats();
}



function saveEdit(type) {
    const content = document.getElementById(`${type}Content`);
    const editButton = document.getElementById('editButton');
    const saveButton = document.getElementById('saveButton');
    
    // Disable editing
    disableEdit(content, editButton, saveButton);
    
    // Lưu lại trạng thái hiện tại của sourceQueue
    const newSourceQueue = [];
    
    // Lấy tất cả các phần tử nội dung (bao gồm cả text và image)
    const contentElements = Array.from(content.children);
    
    contentElements.forEach((element, index) => {
        if (element.classList.contains('content-item')) {
            // Xử lý phần tử text
            const text = element.textContent.trim();
            if (text) {
                newSourceQueue.push({
                    type: 'text',
                    text: text,
                    tag: element.dataset.tag
                });
            }
        } else if (element.classList.contains('content-image')) {
            // Giữ lại thông tin hình ảnh từ sourceQueue cũ
            const originalIndex = parseInt(element.dataset.index);
            const originalImage = state.sourceQueue[originalIndex];
            if (originalImage && originalImage.type === 'image') {
                newSourceQueue.push(originalImage);
            }
        }
    });
    
    // Cập nhật sourceQueue
    state.sourceQueue = newSourceQueue;
    
    // Dịch và tái tạo nội dung mới
    translateEditedContent();
    
    showToast('Changes saved and content re-translated', 'success');
}

async function translateEditedContent() {
    const sourceLang = document.getElementById('sourceLang').value;
    const targetLang = document.getElementById('targetLang').value;
    const targetContent = document.getElementById('targetContent');
    
    // Clear target content
    state.targetQueue = [];
    targetContent.innerHTML = '';
    
    // Xử lý từng item trong sourceQueue
    for (let i = 0; i < state.sourceQueue.length; i++) {
        const item = state.sourceQueue[i];
        
        if (item.type === 'image') {
            // Copy hình ảnh trực tiếp sang targetQueue
            state.targetQueue.push({...item});
            appendContentItem(item, i, 'target');
        } else if (item.type === 'text') {
            try {
                const translatedText = await translate(item.text, sourceLang, targetLang);
                if (translatedText) {
                    const targetItem = { 
                        type: 'text',
                        text: translatedText,
                        tag: item.tag
                    };
                    state.targetQueue.push(targetItem);
                    appendContentItem(targetItem, i, 'target');
                }
            } catch (error) {
                console.error('Translation error:', error);
                showToast(`Translation failed for section ${i + 1}`, 'error');
            }
        }
    }
    
    updateStats();
}

function toggleEdit(type) {
    const content = document.getElementById(`${type}Content`);
    const editButton = document.getElementById('editButton');
    const saveButton = document.getElementById('saveButton');
    
    if (!content.contentEditable || content.contentEditable === 'false') {
        // Enable editing
        content.contentEditable = true;
        content.focus();
        
        // Thêm class editing cho container
        content.classList.add('editing');
        
        // Đánh dấu các phần tử image là không được edit
        content.querySelectorAll('.content-image').forEach(img => {
            img.contentEditable = false;
        });
        
        editButton.classList.add('hidden');
        saveButton.classList.remove('hidden');
        
        // Add visual feedback
        content.style.padding = '1rem';
        content.style.border = '2px solid var(--primary-400)';
    } else {
        // Disable editing without saving
        disableEdit(content, editButton, saveButton);
    }
}







    </script>
</body>
</html>